---
title: "《对Design factors in mouse-tracking: What makes a difference的可重复性研究》"
author: "曹钟文、孙睿忻、姜文彬、郭冰冰"
date: "`r format(Sys.Date(), '%Y年%m月%d日')`"
output: 
  pdf_document:
    latex_engine: xelatex
    keep_tex: true
header-includes:
  - \usepackage{fontspec}
  - \setmainfont{SimSun}      # 设置中文字体为宋体
  - \setsansfont{SimSun}      # 设置无衬线字体为宋体
  - \setmonofont{SimSun}      # 设置等宽字体为宋体，使代码与正文字体大小接近
  - \usepackage{titling}      # 控制标题页格式
  - \pretitle{\begin{center}\Huge\bfseries}
  - \posttitle{\par\end{center}\vskip 1em}
  - \preauthor{\begin{center}\large}
  - \postauthor{\end{center}}
  - \predate{\begin{center}\large}
  - \postdate{\end{center}}
---

\newpage

---
# 数据预处理和环境配置

## 加载 R 包
```{r,message=FALSE}
# 加载所需的 R 包：mousetrap 用于鼠标轨迹分析，ggplot2 用于绘图，dplyr、tidyr 用于数据处理，
# afex 和 MBESS 用于方差分析与效应量估计，ordinal 用于有序回归分析。
library(mousetrap)
library(ggplot2)
library(dplyr)
library(tidyr)
library(afex)
library(MBESS)
library(ordinal)
library(emmeans)
library(maps)
options(warn = -1)  # 关闭所有警告
```

## 自定义 ggplot2 主题
```{r}
# 设置 ggplot2 图形的主题，使图形更美观且更适合科研展示。
theme_set(theme_classic()+ 
  theme(
    axis.line = element_line(colour = "black"),
    axis.ticks = element_line(colour = "black"),
    axis.text = element_text(colour = "black"),
    panel.border = element_rect(colour = "black", fill=NA)
  ))
```

## 自定义函数
```{r}
# 自定义函数：计算偏 Eta 平方（partial eta-squared）及其置信区间，
# 用于衡量方差分析中的效应量。
get_partial_etas <- function(anova_table, conf.level=.90){
  partial_etas <- sapply(row.names(anova_table),function(i){
    F <- anova_table[i,"F"]
    df1 <- anova_table[i,"num Df"]
    df2 <- anova_table[i,"den Df"]
    ci <- conf.limits.ncf(F.value=F,conf.level=conf.level,df.1=df1,df.2=df2)
    return(
      c(pes=((F*df1)/(F*df1+df2)),
        lower=ci$Lower.Limit/(ci$Lower.Limit+df1+df2+1),
        upper=ci$Upper.Limit/(ci$Upper.Limit+df1+df2+1)))
  })
  return(t(partial_etas))
}
```

## 导入数据
```{r}
# 导入原始实验数据，并将 Condition 和 group 设置为因子类型，指定顺序。
raw_data <- read.csv("C:/Users/86139/Desktop/exp3.csv")
raw_data$Typicality <- factor(raw_data$Condition,levels=c("Typical","Atypical"))
raw_data$group <- factor(raw_data$group,levels=c("static","rtmax","initmax","dynamic"))
```

# 正确性分析 - 包括所有试次

## 每个条件的正确反应比例
```{r}
# 计算每组中正确反应的比例。
with(raw_data,table(group, correct)/c(table(group)))
```

## 卡方检验
```{r}
# 使用卡方检验检验正确率是否在各组之间有显著差异。
chisq.test(with(raw_data,table(group, correct)),correct = FALSE)
```

## 广义线性混合模型
```{r}
# 使用 GLMM 检验 group 是否对正确率有影响，包含被试作为随机效应。
contrasts(raw_data$group)
summary(glmer(correct~(1|subject_nr)+group,family="binomial",data=raw_data))
```

# 正确性分析 - 排除 rtmax 条件下超时试次

## 排除超时试次
```{r}
# 计算 rtmax 条件下响应为 None（超时）的试次数量和比例。
n_eligible <- sum(with(raw_data,group=="rtmax" & response!="None"))
n_noneligible <- sum(with(raw_data,group=="rtmax" & response=="None"))
n_noneligible/(n_eligible+n_noneligible)

# 删除超时的试次。
raw_data <- subset(raw_data, response!="None")
```

## 每个条件的正确反应比例（更新）
```{r}
# 重新计算每组的正确率。
with(raw_data,table(group, correct)/c(table(group)))
```

## 卡方检验（更新）
```{r}
# 再次进行卡方检验。
chisq.test(with(raw_data,table(group, correct)),correct = FALSE)
```

## GLMM 模型（更新）
```{r}
# 再次拟合 GLMM 模型，排除超时试次后的数据。
summary(glmer(correct~(1|subject_nr)+group,family="binomial",data=raw_data))
```

## 排除错误试次
```{r}
# 进一步排除错误试次，只保留正确的反应。
raw_data <- subset(raw_data, correct==1)
```

# 鼠标轨迹预处理
```{r}
# 导入鼠标轨迹数据，进行坐标映射、起点对齐、导数计算、标准指标提取、时间标准化。
mt_data <- mt_import_mousetrap(raw_data,
  xpos_label = c("xpos_initial_phase","xpos_get_response"),
  ypos_label = c("ypos_initial_phase","ypos_get_response"),
  timestamps_label = c("timestamps_initial_phase","timestamps_get_response"))
mt_data <- mt_remap_symmetric(mt_data)
mt_data <- mt_align_start(mt_data, start=c(0,0))
mt_data <- mt_derivatives(mt_data)
mt_data <- mt_measures(mt_data)
mt_data <- mt_time_normalize(mt_data)
```

# 操作检验（平均值）

## 聚合每位参与者的时间变量
```{r}
# 添加时间变量，并按被试聚合计算均值。
mt_data$measures$RT_initial <- mt_data$data$response_time_initial_phase
mt_data$measures$IT <- mt_data$measures$initiation_time
mt_data$measures$RT_post <- mt_data$data$response_time_get_response

agg_times <- mt_aggregate_per_subject(mt_data,
  use_variables = c("RT_initial","IT","RT","RT_post"),
  use2_variables = "group",subject_id="subject_nr")
```

## 描述性统计
```{r}
# 输出各组的均值和标准差。
mean_times <- agg_times %>%
  group_by(group) %>%
  summarize(
    N = n(),
    M_RT_inital = mean(RT_initial),
    SD_RT_initial = sd(RT_initial),
    M_IT = mean(IT),
    SD_IT = sd(IT),
    M_RT = mean(RT),
    SD_RT = sd(RT)
    ) %>%
  as.data.frame()
print(mean_times, digits=5)

# 分析 RT_post（动态条件）
agg_times %>%
  group_by(group) %>%
  summarize(
    M_RT_post = mean(RT_post),
    SD_RT_post = sd(RT_post)
  )%>%
  as.data.frame()
```

## 设置对比矩阵
```{r}
# 定义三种实验条件相对于 static 基线组的对比。
contrast_matrix_separate <- list(
  rtmax_vs_static = c(-1,1,0,0),
  initmax_vs_static = c(-1,0,1,0),
  dynamic_vs_static= c(-1,0,0,1))
```

## 比较 RT_initial
```{r}
# RT_initial 的方差分析与对比分析。
anova_RT_initial <- aov_ez(data=agg_times,dv = "RT_initial", between = "group", id = "subject_nr")
nice(anova_RT_initial,es = c("pes","ges"))
round(get_partial_etas(anova_RT_initial$anova_table, conf.level=.90),2)
anova_RT_initial_grid <- lsmeans(anova_RT_initial,~group)
contrast(anova_RT_initial_grid,contrast_matrix_separate)
```

## 比较启动时间 IT
```{r}
# IT 的方差分析与对比分析。
anova_IT <- aov_ez(data=agg_times,dv = "IT", between = "group", id = "subject_nr")
nice(anova_IT,es = c("pes","ges"))
round(get_partial_etas(anova_IT$anova_table, conf.level=.90),2)
anova_IT_grid <- lsmeans(anova_IT,~group)
contrast(anova_IT_grid,contrast_matrix_separate)
```

## 比较总 RT
```{r}
# 总 RT 的方差分析与对比分析。
anova_RT <- aov_ez(data=agg_times,dv = "RT", between = "group", id = "subject_nr")
nice(anova_RT,es = c("pes","ges"))
round(get_partial_etas(anova_RT$anova_table, conf.level=.90),2)
anova_RT_grid <- lsmeans(anova_RT,~group)
contrast(anova_RT_grid,contrast_matrix_separate)
```

# 操作检验（中位数）

## 中位数聚合数据
```{r}
# 使用中位数对时间变量按参与者聚合。
agg_times <- mt_aggregate_per_subject(mt_data,
  use_variables = c("IT","RT_initial","RT"),
  use2_variables = "group",subject_id="subject_nr",
  .funs="median")
```

## 描述性统计
```{r}
# 输出中位数聚合后的均值和标准差。
mean_times <- agg_times %>%
  group_by(group) %>%
  summarize(
    N = n(),
    M_RT_inital = mean(RT_initial),
    SD_RT_initial = sd(RT_initial),
    M_IT = mean(IT),
    SD_IT = sd(IT),
    M_RT = mean(RT),
    SD_RT = sd(RT)
    ) %>%
  as.data.frame()

print(mean_times, digits=5)
```

## 比较 RT_initial
```{r}
# 中位数方式的 RT_initial 方差分析与对比分析。
anova_RT_initial <- aov_ez(data=agg_times,dv = "RT_initial", between = "group", id = "subject_nr")
nice(anova_RT_initial,es = c("pes","ges"))
round(get_partial_etas(anova_RT_initial$anova_table, conf.level=.90),2)
anova_RT_initial_grid <- lsmeans(anova_RT_initial,~group)
contrast(anova_RT_initial_grid,contrast_matrix_separate)
```

## 比较启动时间 IT
```{r}
# 中位数方式的 IT 方差分析与对比分析。
anova_IT <- aov_ez(data=agg_times,dv = "IT", between = "group", id = "subject_nr")
nice(anova_IT,es = c("pes","ges"))
round(get_partial_etas(anova_IT$anova_table, conf.level=.90),2)
anova_IT_grid <- lsmeans(anova_IT,~group)
contrast(anova_IT_grid,contrast_matrix_separate)
```

## 比较总 RT
```{r}
# 中位数方式的总 RT 方差分析与对比分析。
anova_RT <- aov_ez(data=agg_times,dv = "RT", between = "group", id = "subject_nr")
nice(anova_RT,es = c("pes","ges"))
round(get_partial_etas(anova_RT$anova_table, conf.level=.90),2)
anova_RT_grid <- lsmeans(anova_RT,~group)
contrast(anova_RT_grid,contrast_matrix_separate)
```

# 聚合轨迹弯曲度

## 平均时间标准化轨迹图
```{r,fig.height=2, fig.width=6}
# 绘制时间标准化后的轨迹图，按 group 分面，颜色区分典型性。
mt_plot_aggregate(mt_data, use = "tn_trajectories", facet_col = "group",
  x = "xpos", y = "ypos", color = "Typicality", subject_id = "subject_nr")+
  xlab("x coordinate (px)") + ylab("y coordinate (px)")+
  scale_color_manual(values = c("black","grey60"))
```

## 比较 MAD 指标

### 每位参与者聚合 MAD 数据
```{r}
# 按 group 和 Typicality 聚合 MAD 指标，用于分析轨迹弯曲度的差异。
agg_mad <- mt_aggregate_per_subject(mt_data, subject_id = "subject_nr",
  use_variables = "MAD", use2_variables = c("Typicality","group"))
```
### Descriptive 和 配对 t 检验
```{r,message=FALSE}
mad_table <- agg_mad %>%
  group_by(group) %>%
  select(MAD,group,Typicality) %>%
  summarize(
    N =  length(MAD[Typicality=="Typical"]),                     # 典型条件下的样本数量
    M_t = mean(MAD[Typicality=="Typical"]),                      # 典型条件下 MAD 的平均值
    SD_t = sd(MAD[Typicality=="Typical"]),                       # 典型条件下 MAD 的标准差
    M_a = mean(MAD[Typicality=="Atypical"]),                     # 非典型条件下 MAD 的平均值
    SD_a = sd(MAD[Typicality=="Atypical"]),                      # 非典型条件下 MAD 的标准差
    t = t.test(MAD[Typicality=="Atypical"],MAD[Typicality=="Typical"],paired=TRUE)$statistic, # 配对样本 t 检验的 t 值
    p = t.test(MAD[Typicality=="Atypical"],MAD[Typicality=="Typical"],paired=TRUE)$p.value,   # 配对样本 t 检验的 p 值
    d = (M_a-M_t)/sd(MAD[Typicality=="Atypical"]-MAD[Typicality=="Typical"])                # 效应量 Cohen's d
    )

mad_table %>%
  as.data.frame() %>%
  print(digits=3)
```

### 图表
```{r,fig.height=3.2, fig.width=4}
ggplot(agg_mad,aes(x=Typicality,y=MAD,linetype=group,group=group))+
  geom_line(stat="summary",fun.y="mean")+                    # 绘制平均值的折线图
  geom_point(stat="summary",fun.y="mean")+                   # 绘制平均值的点
  geom_errorbar(stat="summary",fun.data="mean_se",width=.2,linetype=1)+  # 添加误差条（标准误）
  scale_linetype_manual(values=c(1,2,3,4))+                    # 手动设置线型样式
  coord_cartesian(ylim=c(0,700))                              # 设置 y 轴范围
```

### 方差分析 ANOVA
```{r}
anova_mad <- aov_ez(data=agg_mad, dv = "MAD", between = "group", within = "Typicality",
                    id = "subject_nr")
nice(anova_mad,es = c("pes","ges"))                          # 显示 ANOVA 结果和效应量（部分 eta 平方、广义 eta 平方）

# 计算部分 eta 平方的 90% 置信区间
round(get_partial_etas(anova_mad$anova_table, conf.level=.90),2)
```

## 对比分析
```{r}
# 获取估计边际均值的组合
anova_mad_grid <- lsmeans(anova_mad,~Typicality:group)

# 指定对比矩阵
contrast_matrix_complete <- list(
  typicality_static = c(-1,1,0,0,0,0,0,0),                    # 静态条件下典型性主效应
  rtmax_static_main=  c(-1,-1,1,1,0,0,0,0)/2,                 # RTmax vs 静态 的主效应
  initmax_static_main = c(-1,-1,0,0,1,1,0,0)/2,               # Initmax vs 静态 的主效应
  dynamic_static_main = c(-1,-1,0,0,0,0,1,1)/2,               # 动态 vs 静态 的主效应
  rtmax_static_int = c(1,-1,-1,1,0,0,0,0),                    # RTmax vs 静态 的交互效应
  initmax_static_int = c(1,-1,0,0,-1,1,0,0),                  # Initmax vs 静态 的交互效应
  dynamic_static_int = c(1,-1,0,0,0,0,-1,1))                  # 动态 vs 静态 的交互效应

# 进行对比检验
contrast(anova_mad_grid,contrast_matrix_complete)
```

# 轨迹形状的分布

## 双峰系数（Bimodality Coefficient）
```{r}
# 按参与者标准化 MAD 值
mt_data <- mt_standardize(mt_data, use_variables = "MAD", within = "subject_nr")

# 计算双峰系数
mt_check_bimodality(mt_data, use_variables = "z_MAD",
  grouping_variables = c("group","Typicality"), methods = "BC")
```

## 平滑热图
```{r,fig.height=1.1, fig.width=6}
heatmap_smoothed <- mt_heatmap_ggplot(mt_data,
  xres = 1000,                       # x 轴分辨率
  smooth_radius = 20,               # 平滑半径
  n_shades = 10,                    # 阴影层级
  mean_image = 0.2,                 # 平均图像透明度
  colors=c("white","black"),        # 使用黑白色调
  facet_col="group")               # 按组分面显示
heatmap_smoothed+
  theme(strip.background = element_rect(colour = NA))  # 去除分面背景边框
```

## 原型分类（标准集合）

### 绘制原型轨迹
```{r,fig.height=1.5}
mt_plot(mt_prototypes,facet_col="mt_id",only_ggplot = TRUE)+
  geom_path()+
  facet_grid(cols = vars(factor(mt_id,levels=rownames(mt_prototypes))))+  # 自定义排列顺序
  theme(axis.text=ggplot2::element_blank(),axis.ticks=ggplot2::element_blank())  # 隐藏坐标轴文本与刻度
```
### 将轨迹映射到原型
```{r}
mt_data <- mt_spatialize(mt_data)
mt_data <- mt_map(mt_data,prototypes = mt_prototypes,
  save_as = "measures", grouping_variables = "group")
mt_data$data$prototype_label <- mt_data$measures$prototype_label
```

### 每组的轨迹分类

#### 相对频率
```{r,fig.height=4.5}
prototype_percentages <- mt_data$data %>%
  group_by(group,prototype_label) %>%
  summarise(n=n()) %>%
  mutate(Percent=paste(round(100*n/sum(n)),"%",sep=""))

mt_plot(mt_data, use = "sp_trajectories",
  x = "xpos", y = "ypos", facet_col = "prototype_label", facet_row="group",alpha=.2)+
  xlab("x 坐标 (px)") + ylab("y 坐标 (px)")+ 
  geom_text(data=prototype_percentages,aes(label=Percent),x=650,y=50)+
  scale_y_continuous(breaks=c(0,500,1000))+ 
  coord_cartesian(xlim=c(-900,900))
```

#### 卡方检验
```{r}
chisq.test(with(mt_data$data,table(group, prototype_label)))
```


### 每组 X 典型性条件的轨迹分类

#### 相对频率
```{r,fig.height=3.2, fig.width=6}
rel_freq_agg <- mt_data$data %>%
  group_by(group,Typicality,prototype_label) %>%
  summarise(n=n()) %>%
  mutate(Percent=n/sum(n))

spread(rel_freq_agg[,-4],"prototype_label","Percent",fill = 0) %>%
  as.data.frame()%>%
  print(digits=2)

ggplot(rel_freq_agg,aes(x=Typicality,y=Percent,fill=forcats::fct_rev(prototype_label)))+
  geom_bar(stat="identity",color="black")+
  scale_fill_brewer(type="seq",name="分类")+
  facet_grid(.~group)
```

#### 有序混合回归
```{r}
contrasts(mt_data$data$Typicality) <- c(-0.5,0.5)
# 对 group 使用默认对比（以 static 为基线的虚拟编码）
contrasts(mt_data$data$group)
summary(clmm(prototype_label~Typicality*group+(1|subject_nr),data=mt_data$data))
```



## 原型分类（扩展原型集）

### 扩展原型集
包含轨迹先向上移动到屏幕顶部然后...
* 向左到达被选选项（upleft）
* 向右到未被选选项然后再向左（upCoM）
* 向左到被选项，然后向右到未被选项，再向左一次（upCoM2）

```{r,fig.height=1.5}
mt_prototypes_ext <- mt_add_trajectory(mt_prototypes,
   xpos = c(0,0,-1), ypos = c(0,1.5,1.5), id = "upleft"
)

mt_prototypes_ext <- mt_add_trajectory(mt_prototypes_ext,
   xpos = c(0,0,1,-1), ypos = c(0,1.5,1.5,1.5), id = "upCoM"
)

mt_prototypes_ext <- mt_add_trajectory(mt_prototypes_ext,
   xpos = c(0,0,-1,1,-1), ypos = c(0,1.5,1.5,1.5,1.5), id = "upCoM2"
)

prototype_labels_extended <- 
  c("straight","curved","upleft","cCoM","upCoM","dCoM","upCoM2","dCoM2")

mt_plot(mt_prototypes_ext,facet_col="mt_id",only_ggplot = TRUE)+
  geom_path()+
  facet_grid(cols = vars(factor(mt_id,levels=prototype_labels_extended)))+
  theme(axis.text=ggplot2::element_blank(),axis.ticks=ggplot2::element_blank()) 
```


### 将轨迹映射到原型
```{r}
mt_data <- mt_spatialize(mt_data)
mt_data <- mt_map(mt_data,prototypes = mt_prototypes_ext,
  save_as="measures", grouping_variables = "group")

# 创建包含所有原型按升序排列的变量
mt_data$data$prototype_label <- factor(mt_data$measures$prototype_label,
  levels=prototype_labels_extended)

# 创建变量，将“up”类型的原型归为其弯曲（curved）等价类别
mt_data$data$prototype_label_red <- factor(mt_data$measures$prototype_label,
  levels=c("straight","curved","upleft","cCoM","upCoM","dCoM","upCoM2","dCoM2"),
  labels=c("straight","curved","curved","cCoM","cCoM", "dCoM","dCoM2", "dCoM2"))
```


### 每组的轨迹分类

#### 相对频率
```{r,fig.height=4.5}
prototype_percentages <- mt_data$data %>%
  group_by(group,prototype_label) %>%
  summarise(n=n()) %>%
  mutate(Percent=paste(round(100*n/sum(n)),"%",sep=""))

mt_plot(mt_data, use = "sp_trajectories",
  x = "xpos", y = "ypos", facet_col = "prototype_label", facet_row="group",alpha=.2)+
  xlab("x 坐标 (px)") + ylab("y 坐标 (px)")+ 
  geom_text(data=prototype_percentages,aes(label=Percent),x=650,y=50)+
  scale_y_continuous(breaks=c(0,500,1000))+ 
  coord_cartesian(xlim=c(-900,900))
```

#### 卡方检验
```{r}
chisq.test(with(mt_data$data,table(group, prototype_label)))
```


### 每组 X 典型性条件的轨迹分类

#### 相对频率
```{r,fig.height=3.2, fig.width=6}
rel_freq_agg <- mt_data$data %>%
  group_by(group,Typicality,prototype_label) %>%
  summarise(n=n()) %>%
  mutate(Percent=n/sum(n), Percent_rounded = round(Percent,2))

spread(rel_freq_agg[,-c(4:5)],"prototype_label","Percent_rounded",fill = 0) %>%
  as.data.frame()

ggplot(rel_freq_agg,aes(x=Typicality,y=Percent,fill=forcats::fct_rev(prototype_label)))+
  geom_bar(stat="identity",color="black")+
  scale_fill_brewer(type="seq",name="分类")+
  facet_grid(.~group)
```

#### 有序混合回归（将所有原型视为有序）
```{r}
summary(clmm(prototype_label~Typicality*group+(1|subject_nr),data=mt_data$data))
```

#### 有序混合回归（将“up”和弯曲原型视为相同）
```{r}
summary(clmm(prototype_label_red~Typicality*group+(1|subject_nr),data=mt_data$data))
```

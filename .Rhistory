n <- nrow(data)
indices <- sample(1:n, replace = TRUE, size = size)
bootstrap_sample <- data[indices, ]
return(bootstrap_sample)
}
# 重复抽样3次
k <- 3
# 存储统计量和回归模型
statistics_beta <- numeric(k)
statistics_R2 <- numeric(k)
models <- list()
# 进行bootstrap抽样、计算统计量、绘制散点图和拟合直线
for (i in 1:k) {
#抽样
bootstrap_sample_data <- bootstrap_sample(data,size=50)
# 计算统计量 beta 和 R^2
x <- bootstrap_sample_data$Exam
y <- bootstrap_sample_data$Anxiety
model <- lm(y ~ x)
beta <- coef(model)[2]
R2 <- summary(model)$r.squared
# 存储统计量和回归模型
statistics_beta[i] <- beta
statistics_R2[i] <- R2
models[[i]] <- model
# 绘制散点图和拟合直线
p <- ggplot(bootstrap_sample_data, aes(x = Exam, y = Anxiety)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "solid", size = 2) +
labs(title = paste("Bootstrap Sample", i), x = "Exam", y = "Anxiety") +
annotate("text", x = Inf, y = Inf, label = paste("β =", round(beta, 3), "\nR^2 =", round(R2, 3)),
hjust = 1, vjust = 1, size = 4, color = "black") +
papaja::theme_apa()  #
print(p)
}
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
# Bootstrap抽样函数,抽取50个子样本
bootstrap_sample <- function(data, size=50) {
n <- nrow(data)
indices <- sample(1:n, replace = TRUE, size = size)
bootstrap_sample <- data[indices, ]
return(bootstrap_sample)
}
# 重复抽样3次
k <- 30
# 存储统计量和回归模型
statistics_beta <- numeric(k)
statistics_R2 <- numeric(k)
models <- list()
# 进行bootstrap抽样、计算统计量、绘制散点图和拟合直线
for (i in 1:k) {
#抽样
bootstrap_sample_data <- bootstrap_sample(data,size=50)
# 计算统计量 beta 和 R^2
x <- bootstrap_sample_data$Exam
y <- bootstrap_sample_data$Anxiety
model <- lm(y ~ x)
beta <- coef(model)[2]
R2 <- summary(model)$r.squared
# 存储统计量和回归模型
statistics_beta[i] <- beta
statistics_R2[i] <- R2
models[[i]] <- model
# 绘制散点图和拟合直线
p <- ggplot(bootstrap_sample_data, aes(x = Exam, y = Anxiety)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "solid", size = 2) +
labs(title = paste("Bootstrap Sample", i), x = "Exam", y = "Anxiety") +
annotate("text", x = Inf, y = Inf, label = paste("β =", round(beta, 3), "\nR^2 =", round(R2, 3)),
hjust = 1, vjust = 1, size = 4, color = "black") +
papaja::theme_apa()  #
print(p)
}
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
# Bootstrap抽样函数,抽取50个子样本
bootstrap_sample <- function(data, size=50) {
n <- nrow(data)
indices <- sample(1:n, replace = TRUE, size = size)
bootstrap_sample <- data[indices, ]
return(bootstrap_sample)
}
# 重复抽样3次
k <- 3
# 存储统计量和回归模型
statistics_beta <- numeric(k)
statistics_R2 <- numeric(k)
models <- list()
# 进行bootstrap抽样、计算统计量、绘制散点图和拟合直线
for (i in 1:k) {
#抽样
bootstrap_sample_data <- bootstrap_sample(data,size=50)
# 计算统计量 beta 和 R^2
x <- bootstrap_sample_data$Exam
y <- bootstrap_sample_data$Anxiety
model <- lm(y ~ x)
beta <- coef(model)[2]
R2 <- summary(model)$r.squared
# 存储统计量和回归模型
statistics_beta[i] <- beta
statistics_R2[i] <- R2
models[[i]] <- model
# 绘制散点图和拟合直线
p <- ggplot(bootstrap_sample_data, aes(x = Exam, y = Anxiety)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "solid", size = 2) +
labs(title = paste("Bootstrap Sample", i), x = "Exam", y = "Anxiety") +
annotate("text", x = Inf, y = Inf, label = paste("β =", round(beta, 3), "\nR^2 =", round(R2, 3)),
hjust = 1, vjust = 1, size = 4, color = "black") +
papaja::theme_apa()  #
print(p)
}
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
library(boot)
# 定义相关系数的统计量函数
statistic <- function(data, indices) {
sampled_data <- data[indices, ]
model <- lm(sampled_data$Anxiety ~ sampled_data$Exam)
beta <- coef(model)[2]
return(beta)
}
# 进行1500次bootstrap抽样与计算统计量
bootstrap_results <- boot(data = data, statistic = statistic, R = 2000)
# 绘制beta的直方图
hist(bootstrap_results$t, main = "Bootstrap Distribution of Beta",
xlab = "Beta Coefficient", ylab = "Density", col = "grey", freq = FALSE, breaks = 80)
mean_beta <- mean(bootstrap_results$t)
abline(v = mean_beta, col = "green", lty = 2)
# 绘制beta的qq图
qqnorm(bootstrap_results$t, main = "Normal Probability Plot for Beta",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(bootstrap_results$t, col = "grey")
#计算95%CI
boot_ci <- boot.ci(bootstrap_results, type = "bca")
boot_ci
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
library(boot)
# 定义决定系数的统计量函数
statistic <- function(data, indices) {
sampled_data <- data[indices, ]
model <- lm(sampled_data$Anxiety ~ sampled_data$Exam)
R2 <- summary(model)$r.squared
return(R2)
}
# 进行1500次bootstrap抽样与计算统计量
bootstrap_results <- boot(data = data, statistic = statistic, R = 1200)
# 绘制beta的直方图
hist(bootstrap_results$t, main = "Bootstrap Distribution of R^2",
xlab = "R^2", ylab = "Density", col = "grey", freq = FALSE, breaks = 80)
mean_R2 <- mean(bootstrap_results$t)
abline(v = mean_R2, col = "green", lty = 2)
# 绘制beta的QQ图
qqnorm(bootstrap_results$t, main = "Normal Probability Plot for Beta",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(bootstrap_results$t, col = "grey")
#计算95%CI
boot_ci <- boot.ci(bootstrap_results, type = "bca")
boot_ci
head(data)
# 加载ggplot2包
library(ggplot2)
# 创建直方图和概率密度曲线
ggplot(data, aes(x = Exam, color = Anxiety_1)) +
geom_histogram(aes(y = after_stat(density)), binwidth = 10, alpha = 0.7, position = "identity") +
geom_density(size = 1) +
facet_wrap(~Anxiety_1, scales = "free_y") +  # 分别绘制两组
labs(title = "Distribution of Exam Scores",
x = "Exam Scores", y = "Density") +
theme_apa() +
scale_color_manual(values = c("low" = "blue", "high" = "red"))
## 计算Cohen’s d
group_A <- subset(data, Anxiety_1 == "high")$Exam
group_B <- subset(data, Anxiety_1 == "low")$Exam
# 计算均值
mean_A <- mean(group_A)
mean_B <- mean(group_B)
# 计算SS_A和SS_B
SS_A <- sum((group_A - mean_A)^2)
SS_B <- sum((group_B - mean_B)^2)
# 计算样本量
n_A <- length(group_A)
n_B <- length(group_B)
# 计算 Cohen’s d
cohen.d <- (mean_A - mean_B) / sqrt((SS_A+ SS_B) / (n_A + n_B - 2))
print(paste("Cohen′d = ", cohen.d))
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
# 定义Cohen's d的统计量函数
bootstrap_cohens_d <- function(data, indices) {
sampled_data <- data[indices, ]
group_A <- subset(sampled_data, Anxiety_1 == "high")$Exam
group_B <- subset(sampled_data, Anxiety_1 == "low")$Exam
mean_A <- mean(group_A)
mean_B <- mean(group_B)
SS_A <- sum((group_A - mean_A)^2)
SS_B <- sum((group_B - mean_B)^2)
n_A <- length(group_A)
n_B <- length(group_B)
cohen.d <- (mean_A - mean_B) / sqrt((SS_A + SS_B) / (n_A + n_B - 2))
return(cohen.d)
}
# 进行1500次Bootstrap
bootstrap_results <- boot(data = data, statistic = bootstrap_cohens_d, R = 1500)
# 绘制Cohen's d的直方图
hist(bootstrap_results$t, main = "Bootstrap Distribution of Cohen's d",
xlab = "Cohen's d", ylab = "Density", ", col = 'grey", freq = FALSE, breaks = 100)
mean_d <- mean(bootstrap_results$t)
abline(v = mean_d, col = 'green', lty = 2)
# 绘制Cohen's d的QQ图
qqnorm(bootstrap_results$t, main = "Normal Probability Plot for Cohen's d",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(bootstrap_results$t, col = "grey")
#计算95%CI
boot_ci <- boot.ci(bootstrap_results, type = "bca")
boot_ci
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
library(boot)
# 定义决定系数的统计量函数
statistic <- function(data, indices) {
sampled_data <- data[indices, ]
model <- lm(sampled_data$Anxiety ~ sampled_data$Exam)
R2 <- summary(model)$r.squared
return(R2)
}
# 进行1500次bootstrap抽样与计算统计量
bootstrap_results <- boot(data = data, statistic = statistic, R = 1200)
# 绘制beta的直方图
hist(bootstrap_results$t, main = "Bootstrap Distribution of R^2",
xlab = "R^2", ylab = "Density", col = "grey", freq = FALSE, breaks = 80)
mean_R2 <- mean(bootstrap_results$t)
abline(v = mean_R2, col = "green", lty = 2)
# 绘制beta的QQ图
qqnorm(bootstrap_results$t, main = "Normal Probability Plot for Beta",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(bootstrap_results$t, col = "grey")
#计算95%CI
boot_ci <- boot.ci(bootstrap_results, type = "bca")
boot_ci
set.seed(123)
norm_data <- rnorm(100, mean = 5, sd = 2)
df <- data.frame(Values = norm_data)
norm_data
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
bruceR::Describe(norm_data)
ggplot(df, aes(x = Values)) +
geom_histogram(aes(y = ..density..), bins = 30, fill = "grey", color = "black") +
labs(title = "Histogram of Normal Column",
x = "Normal Values",
y = "Rel.Freq(Normal in bin)")+
theme_apa()
# 定义似然函数
likelihood <- function(params) {
mu <- params[1]  # 均值参数
sigma <- params[2]  # 标准差参数
# 计算观测数据的似然值
log_likelihood <- sum(dnorm(norm_data, mean = mu, sd = sigma, log = TRUE))
return(-log_likelihood)  # 最大化似然函数等效于最小化相反数
}
# 使用最大似然法进行参数估计
initial_params <- c(mean(norm_data), sd(norm_data))  # 初始参数值
estimated_params <- optim(initial_params, likelihood)$par
# 输出估计的参数值
estimated_mean <- estimated_params[1]
estimated_sd <- estimated_params[2]
print(paste("估计的均值:", estimated_mean))
print(paste("估计的标准差:", estimated_sd))
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
# 直方图
hist(norm_data, probability = TRUE, main = "Histogram and PDF Comparison",
xlab = "Values", ylab = "Density", col = "lightblue", border = "black")
# 理论概率密度函数曲线
curve(dnorm(x, mean = 5, sd = 2),
col = "red", lwd = 2, add = TRUE, yaxt = "n")
legend("topright", legend = c("Histogram", "theoretical pdf"), fill = c("lightblue", "red"))
# QQ图
qqnorm(norm_data, main = "QQ Plot")
qqline(norm_data, col = "grey")
# Kolmogorov-Smirnov检验
ks_result <- ks.test(norm_data, "pnorm",mean = 5, sd = 2) # 检查数据是否服从mean=5，sd=2的正态分布
ks_result
#| code-fold: true    #指示折叠或展开代码
#| code-summary: "expand for full code"    #代码块说明文字
#| fig-align: "center"      #设置图形居中显示
# 直方图
hist(norm_data, probability = TRUE, main = "Histogram and PDF Comparison",
xlab = "Values", ylab = "Density", col = "lightblue", border = "black")
# 理论概率密度函数曲线
curve(dnorm(x, mean = 5, sd = 2),
col = "red", lwd = 2, add = TRUE, yaxt = "n")
legend("topright", legend = c("Histogram", "theoretical pdf"), fill = c("lightblue", "red"))
# QQ图
qqnorm(norm_data, main = "QQ Plot")
qqline(norm_data, col = "grey")
# Kolmogorov-Smirnov检验
ks_result <- ks.test(norm_data, "pnorm",mean = 5, sd = 2) # 检查数据是否服从mean=5，sd=2的正态分布
ks_result
# 有多种写法
# 用 here::here 函数进行查找
# 也可以用基础包，输入路径读取
Q1 <- read_csv(here::here("data/penguin/penguin_rawdata.csv"))
library(readr)
library(here)
Q1 <- read_csv(here::here("data/penguin/penguin_rawdata.csv"))
Q1
library(dplyr)
Q2 <- Q1 %>%
filter(site == "Bamber") %>%
slice(1:20)
library(dplyr)
Q2 <- Q1 %>%
filter(Site == "Bamber") %>%
slice(1:20)
Q2
library(dplyr)
Q2 <- Q1 %>%
filter(Site == "Bamberg") %>%
slice(1:20)
Q2
Q3 <- Q2 %>%
select(health, starts_with("phone"))
# 查看变量类型
str(Q3)
# 如果是字符变量，转为数值
Q3 <- Q3 %>%
mutate(across(everything(), as.numeric))
str(Q3)
Q4 <- Q3 %>%
mutate(health = recode(health,
`5` = "Excelent",
`4` = "Very Good",
`3` = "Good",
`2` = "Fair",
`1` = "Poor"))
Q4
Q5 <- factor(Q4$health,
levels = c("Poor", "Fair", "Good", "Very Good", "Excelent"),
ordered = TRUE)
Q5
```
Q6_1 <- "Poor" %in% Q5
Q6_2 <- "Fair" %in% Q5
Q6_1
Q6_2
```
Q7 <- paste(Q5, collapse = ",")
Q7
library(stringr)
Q8 <- str_length(Q5)
Q8
Q9 <- str_sub(Q5, 1, 1)
Q9
Q10 <- Q4 %>%
mutate(Num = row_number())
Q10
Q11 <- Q10 %>%
filter(health %in% c("Good", "Very Good", "Excelent")) %>%
pull(Num)
Q11
Q10 <- Q10 %>%
mutate(phone_total = rowSums(select(., starts_with("phone")), na.rm = TRUE))
Q10
Q13 <- Q10 %>%
filter(health %in% c("Good", "Very Good", "Excelent"),
phone_total >= 36)
Q13
func <- function(a = 1, b = 1) {
(a + b)^2
}
Q14 <- func(3, 4)
Q14
func2 <- function(x) {
data.frame(mean = mean(x), sd = sd(x))
}
Q15 <- func2(c(1, 2, 3, 4, 5))
Q15
fun3 <- function(x = 10) {
x %% 2 == 0
}
Q16 <- fun3(22)
Q16
func4 <- function(x) {
if (x > 0) {
"Positive"
} else if (x < 0) {
"Negative"
} else {
"Zero"
}
}
Q17 <- func4(-3)
Q17
func5 <- function(x) {
if (x >= 90) {
"A"
} else if (x >= 80) {
"B"
} else if (x >= 70) {
"C"
} else if (x >= 60) {
"D"
} else {
"E"
}
}
Q18 <- func5(95)
Q18
```
getwd()
library(readr)
library(here)
Q1 <- read_csv(here::here("data/penguin/penguin_rawdata.csv"))
Q1
library(dplyr)
Q2 <- Q1 %>%
filter(Site == "Bamberg") %>%
slice(1:20)
Q2
Q3 <- Q2 %>%
select(health, starts_with("phone"))
# 查看变量类型
str(Q3)
# 如果是字符变量，转为数值
Q3 <- Q3 %>%
mutate(across(everything(), as.numeric))
str(Q3)
Q4 <- Q3 %>%
mutate(health = recode(health,
`5` = "Excelent",
`4` = "Very Good",
`3` = "Good",
`2` = "Fair",
`1` = "Poor"))
Q4
Q5 <- factor(Q4$health,
levels = c("Poor", "Fair", "Good", "Very Good", "Excelent"),
ordered = TRUE)
Q5
```
Q7 <- paste(Q5, collapse = ",")
Q7
Q9 <- str_sub(Q5, 1, 1)
Q9
Q10 <- Q4 %>%
mutate(Num = row_number())
Q10
Q11 <- Q10 %>%
filter(health %in% c("Good", "Very Good", "Excelent")) %>%
pull(Num)
Q11
Q10 <- Q10 %>%
mutate(phone_total = rowSums(select(., starts_with("phone")), na.rm = TRUE))
Q10
Q13 <- Q10 %>%
filter(health %in% c("Good", "Very Good", "Excelent"),
phone_total >= 36)
Q13
func <- function(a = 1, b = 1) {
(a + b)^2
}
Q14 <- func(3, 4)
Q14
func2 <- function(x) {
data.frame(mean = mean(x), sd = sd(x))
}
Q15 <- func2(c(1, 2, 3, 4, 5))
Q15
fun3 <- function(x = 10) {
x %% 2 == 0
}
Q16 <- fun3(22)
Q16
func4 <- function(x) {
if (x > 0) {
"Positive"
} else if (x < 0) {
"Negative"
} else {
"Zero"
}
}
Q17 <- func4(-3)
Q17
func5 <- function(x) {
if (x >= 90) {
"A"
} else if (x >= 80) {
"B"
} else if (x >= 70) {
"C"
} else if (x >= 60) {
"D"
} else {
"E"
}
}
Q18 <- func5(95)
Q18
```
